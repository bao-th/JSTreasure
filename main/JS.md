# JavaScript

## 运行阶段

1. 编译阶段
   - 基本语法规则校验、如果有错，直接报错，且停止运行
   - 声明变量或函数
2. 执行阶段
   - 执行代码，赋值、运算、函数的调用

---

## 函数

### 高阶函数

1. 若 A 函数，接收的参数是一个函数，那么 A 就可以称之为高阶函数。
2. 若 A 函数，调用的返回值依然是一个函数，那么 A 就可以称之为高阶函数。

`常见的高阶函数有：Promise、setTimeout、arr.map()等等`

### 函数的柯里化

`通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式`

### 纯函数

1. 一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)
2. 必须遵守以下一些约束
   - 不得改写参数数据
   - 不会产生任何副作用，例如网络请求，输入和输出设备
   - 不能调用 Date.now()或者 Math.random()等不纯的方法
3. redux 的 reducer 函数必须是一个纯函数

### 函数声明与变量声明的匿名函数

1. 区别：
   - 函数声明可以提前，可以先调用后声明，变量声明的为 undefined
   - 关键字声明的函数，在一定的条件下会比，变量声明的匿名函数更加占用内存

### 语法规则

1. JS 中函数可以作为值使用，是一个基本的语法规则
2. JS 中函数本身的作用域在声明的地方，与在哪个地方调用，没有关系

### 闭包（闭合的数据包）

- 产生条件：一个函数中返回一个函数
- 定义：因为垃圾回收机制不会破坏基本语法规则，所以父函数中被子函数引用的变量、及子函数都不会回收，全局作用域又引用不到这些数据，所以这些数据就形成一个闭合的数据包

### 回调函数

- 一个函数作为参数，传递给另一个函数，另一个函数执行完后，再执行传递进来的函数，这个过程叫做回调，传递的函数叫做回调函数

1. 同步回调
   - 理解：立即执行，完全执行完了才结束，不会放入回调队列
   - 例子：数组遍历相关的回调函数、Promise 的 executor 函数
2. 异步回调
   - 理解：不会立即执行，会放入回调队列中将来执行
   - 例子：定时器回调、ajax 回调、Promise 的成功|失败的回调

---

## JS 中的错误(Error)和错误处理

1. 错误的类型
   - Error：所有错误的夫类型
   - ReferenceError：引用的变量不存在
   - TypeError：数据类型不正确的错误
   - RangeError：数据值不在其所允许的范围内
   - SyntaxError：语法错误
2. 错误处理
   - 捕获错误：try ... catch
   - 抛出错误：throw error
3. 错误对象
   - message 属性：错误相关信息
   - stack 属性：函数调用栈记录信息

---

## JS 异步之宏队列与微队列

1. JS 中用来存储待执行回调函数的队列包含 2 个不同特定的队列
2. 宏队列：用来保存待执行的宏任务（回调），比如：`定时器回调/DOM事件回调/ajax回调`
3. 微队列：用来保存待执行的微任务（回调），比如：`promise回调/MutationObserver回调`
4. JS 执行时会区别这 2 个队列
   - JS 引擎首先必须先执行所有的初始化同步任务代码
   - 每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个取出来执行
